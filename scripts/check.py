"""In this file I attempt to filter servers that are not responsive from the list ofknown DNS resolvers, NTP servers and Memcached servers."""import socketimport timefrom scapy.layers.dns import DNS, DNSQR, DNSRRfrom scapy.layers.inet import IP, UDP, ICMPfrom scapy.layers.ntp import NTPfrom scapy.packet import Rawfrom scapy.sendrecv import sr1, send, snifffrom scapy.volatile import RandShort# from pymemcache.client.base import Client# from measure import is_ntp_responsefrom utils import read_ips, save_ipsdef check_dns(ip):    """    Checks if the given IP address of a DNS server is responsive.    :param ip: the IP address of a DNS server.    :return: True if IP is responsive, False otherwise.    """    try:        pkt = IP(dst=ip) / UDP(dport=53, sport=RandShort()) / DNS(rd=1, qd=DNSQR(qname="google.com"))        response = sr1(pkt, timeout=0.4, verbose=0)  # "verbose" flag can be set to 1 to see the logs.        return response is not None and response[DNS].rcode != 2 and response[            DNS].rcode != 5  # 2 stands for servfail and 5 stands for the refused        # https://help.dnsfilter.com/hc/en-us/articles/4408415850003-DNS-return-codes    except Exception as e:        print(f"Error checking DNS for {ip}: {e}")        return Falsedef check_ntp(ip):    """    Checks if a NTP server is responsive.    :param ip: the address of the NTP server    :return: True if the NTP server is responsive, False otherwise    """    try:        pkt = IP(dst=ip) / UDP(dport=123, sport=RandShort()) / NTP(version=4, mode=3)        response = sr1(pkt, timeout=0.2, verbose=0)  # "verbose" flag can be set to 1 to see the logs.        return response is not None    except Exception as e:        print(f"Error checking NTP for {ip}: {e}")        return Falsedef check_ntp_monlist(ip):    """    Checks if a NTP server responds to a monlist query    :param ip: the destination host address    :return: a boolean, true if the NTP server is responsive to `monlist`, false otherwise    """    data = "\x17\x00\x03\x2a" + "\x00" * 4  # 0x17 for private mode, 0x00 for response, 0x03 for version, 0x2a for monlist    try:        pkt = (IP(dst=ip) / UDP(dport=123, sport=RandShort()) / Raw(load=data))        send(pkt)        responses = sniff(timeout=1, lfilter=lambda x: is_ntp_response(x, ip))        if responses:            return True        else:            return False    except Exception as e:        print(f"Error checking NTP monlist for {ip}: {e}")# NTP header# +-------+-------+-------+# | LI    | VN    | Mode  |# +-------+-------+-------+# | 2 bits| 3 bits| 3 bits|# +-------+-------+-------+# LI => leap indicator# VN => version numberdef check_ntp_version(ip):    # Modes: 3 (client), 4 (server), 5 (broadcast)    # VN (version number): Typically 2, 3, or 4    packet = IP(dst=ip) / UDP(sport=RandShort(), dport=123) / NTP(version=4, mode=3)    try:        response = sr1(packet, timeout=2)        if response:            response.show()            return True        else:            return False    except Exception as e:        print(f"Error checking NTP version for {ip}: {e}")def check_memcached_socket(ip):    """    Checks if the Memcached server is responsive.    :param ip: the IP address of the server    :return: True if the Memcached server is responsive, False otherwise    """    try:        # s = socket.socket(socket.AF_INET, socket.SOCK_STREAM) => THIS IS OVER TCP!!        s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)        message = b'stats slabs\r\n'        server_address = (ip, 11211)        s.settimeout(2)  # set the timeout        # s.connect((ip, 11211))  ## 11211 is the default port for memcached => THIS IS OVER TCP!!!!        try:            s.sendto(message, server_address) # send a "stats slabs" query            data, _ = s.recvfrom(4096)            if data:                return True            else:                return False        finally:            s.close()    except Exception as e:        print(f"Error checking Memcached for {ip}: {e}")        return Falsedef check_memcached_scapy(ip):    """    Checks if a Memcached server is responsive (i.e. if it responds to stats slabs request).    :param ip: the address of the Memcached server    :return: True if the Memcached server is responsive, False otherwise    """    try:        pkt = IP(dst=ip) / UDP(sport=RandShort(), dport=11211) / Raw(load="\x00\x01\x00\x00\x00\x01\x00\x00stats slabs\r\n")        # \x00 => this is the first byte of the payload and represents the magic byte the memcached protocol.        # for a request, the magic byte is usually \x00.        # \x01 => this is the opcode, \x01 indicates the stats command. (an upper command, what is written later in ascii is the subcommand)        # \x00\x00 => these two bytes are the key length. since the stats command doesn't use a key, this is set to \x00\x00.        # \x00 => this byte is for the extra length, which indicates the length of any extra data, for the stats command, this is 0 because there is no extra data.        # \x01 => this byte is the data type, (0x00 for raw bytes).        # \x00\x00 => these two bytes are the reserved or unused bytes. They can be set to 0.        response = sr1(pkt, timeout=1, verbose=0)  # set verbose to 1 to see logs        # Check if response is None        if response is None:            return False        # Check if the response is of type ICMP        if response.haslayer(ICMP):            return False        # Check if response has STAT in the payload        if response.haslayer(Raw) and b"STAT" in response[Raw].load:            return True    except Exception as e:        print(f"Error checking Memcached for {ip}: {e}")        return False# def check_memcached_memcached_client(ip):#     """#       Checks if the Memcached server is responsive.#       :param ip: the IP address of the server#       :return: True if the Memcached server is responsive, False otherwise#       """#     try:#         client = Client((ip, 11211), timeout=2)#         stats = client.stats("slabs")#         if stats:#             return True#         else:#             return False#     except Exception as e:#         print(f"Error checking Memcached for {ip}: {e}")#         return Falsedef filter_ips(ips, check_function):    """    Filters IP addresses according to check_function.    :param ips: the initial list of addresses    :param check_function: the function to be used to filter IP addresses, depending on the protocol    :return: a filtered list of IP addresses    """    valid_ips = []    initial_size = len(ips)    for i in range(len(ips)):        ip = ips[i]        if check_function(ip):            valid_ips.append(ip)        time.sleep(0.1)  # introduce delay between subsequent checks to reduce uplink load        if (i % 50 == 0):            print(f"Progress: {i} / {initial_size}")    return valid_ipsdef main():    input_file = input("Please input the file path of the IP addresses \n")    mode = input("Please enter the service type (DNS/NTP/Memcached): ").lower()    ips = read_ips(input_file)    # Depending on the mode, we will use different check methods    if mode == 'dns':        filtered_ips = filter_ips(ips, check_dns)    elif mode == 'ntp':        wants_monlist = input("Please enter true or false if you want NTP servers to be filtered for monlist: ").lower()        if wants_monlist == 'true':            filtered_ips = filter_ips(ips, check_ntp_monlist)        else:            filtered_ips = filter_ips(ips, check_ntp)    elif mode == 'memcached':        filtered_ips = filter_ips(ips, check_memcached_scapy)    else:        print("Incorrect mode. Please enter either 'dns', 'ntp' or 'memcached'!")        return    print("Before filtering, the amount of IPs was {}".format(len(ips)))    print("After filtering, the amount of IPs was {}".format(len(filtered_ips)))    # output_file = "./memtest_res.csv"    output_file = input("Please enter the output fle path \n")    save_ips(filtered_ips, output_file)if __name__ == "__main__":    main()